<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="博客" />
       
      <meta name="description" content="日常随笔" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Linux TCP套接字详细配置 |  Lijintao&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Lijintao's Blog" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="Linux-Linux-TCP套接字详细配置"
  class="article article-type-Linux"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux TCP套接字详细配置
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/16/Linux-TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2024-10-16T01:51:01.000Z" itemprop="datePublished">2024-10-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">9.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">37 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p>提高服务器的负载能力，是一个永恒的话题。在一台服务器CPU和内存资源额定有限的情况下，最大的压榨服务器的性能，是最终的目的。要提高 Linux系统下的负载能力，可以先启用Apache的Worker模式，来提高单位时间内的并发量。但是即使这么做了，当网站发展起来之后，连接数过多 的问题就会日益明显。在节省成本的情况下，可以考虑修改Linux的内核TCP&#x2F;IP参数，来最大的压榨服务器的性能。当然，如果通过修改内核参数也无法 解决的负载问题，也只能考虑升级服务器了，这是硬件所限，没有办法的事。</p>
<p>Linux系统下，TCP&#x2F;IP连接断开后，会以TIME_WAIT状态保留一定的时间，然后才会释放端口。当并发请求过多的时候，就会产生大量的 TIME_WAIT状态的连接，无法及时断开的话，会占用大量的端口资源和服务器资源（因为关闭后进程才会退出）。这个时候我们可以考虑优化TCP&#x2F;IP 的内核参数，来及时将TIME_WAIT状态的端口清理掉。<br>本文介绍的方法只对拥有大量TIME_WAIT状态的连接导致系统资源消耗有效，不是这个原因的情况下，效果可能不明显。那么，到哪儿去查 TIME_WAIT状态的连接呢？那就是使用netstat命令。我们可以输入一个复核命令，去查看当前TCP&#x2F;IP连接的状态和对应的个数：</p>
<p>#netstat -n | awk ‘&#x2F;^tcp&#x2F; {++S[$NF]} END {for(a in S) print a, S[a]}’</p>
<p>这个命令会显示出类似下面的结果：</p>
<p>LAST_ACK 14<br>SYN_RECV 348<br>ESTABLISHED 70<br>FIN_WAIT1 229<br>FIN_WAIT2 30<br>CLOSING 33<br>TIME_WAIT 18122</p>
<p>我们只用关心TIME_WAIT的个数，在这里可以看到，有18000多个TIME_WAIT，这样就占用了18000多个端口。要知道端口的数量 只有65535个，占用一个少一个，会严重的影响到后继的新连接。这种情况下，我们就有必要调整下Linux的TCP&#x2F;IP内核参数，让系统更快的释放 TIME_WAIT连接。</p>
<p>我们用vim打开配置文件：</p>
<p>#vim &#x2F;etc&#x2F;sysctl.conf</p>
<p>然后，在这个文件中，加入下面的几行内容：</p>
<p>net.ipv4.tcp_syncookies &#x3D; 1<br>net.ipv4.tcp_tw_reuse &#x3D; 1<br>net.ipv4.tcp_tw_recycle &#x3D; 1<br>net.ipv4.tcp_fin_timeout &#x3D; 30</p>
<p>最后输入下面的命令，让内核参数生效：</p>
<p>#&#x2F;sbin&#x2F;sysctl -p</p>
<p>简单的说明下，上面的参数的含义：</p>
<p>net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；<br>net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间。</p>
<p>在经过这样的调整之后，除了会进一步提升服务器的负载能力之外，还能够防御一定程度的DDoS、CC和SYN攻击，是个一举两得的做法。</p>
<p>此外，如果你的连接数本身就很多，我们可以再优化一下TCP&#x2F;IP的可使用端口范围，进一步提升服务器的并发能力。依然是往上面的参数文件中，加入下面这些配置：</p>
<p>net.ipv4.tcp_keepalive_time &#x3D; 1200<br>net.ipv4.ip_local_port_range &#x3D; 10000 65000<br>net.ipv4.tcp_max_syn_backlog &#x3D; 8192<br>net.ipv4.tcp_max_tw_buckets &#x3D; 5000</p>
<p>这几个参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置这几个参数。这几个参数的含义如下：</p>
<p>net.ipv4.tcp_keepalive_time &#x3D; 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。<br>net.ipv4.ip_local_port_range &#x3D; 10000 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）<br>net.ipv4.tcp_max_syn_backlog &#x3D; 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。<br>net.ipv4.tcp_max_tw_buckets &#x3D; 5000 表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。</p>
<p>经过这样的配置之后，你的服务器的TCP&#x2F;IP并发能力又会上一个新台阶。</p>
<p>们这里应用的是CentOS5.3，并内核使用的是2.6.18-128.el5PAE #1 SMP 。修改部分TCP ，有的是为了提高性能与负载，但是存在降低稳定性的风险。有的则是安全方面的配置，则有可能牺牲了性能。</p>
<p><strong>1.TCP keepalive TCP连接保鲜设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1800 &gt; /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">echo 15 &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">echo 5 &gt; /proc/sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure>

<p>keepalive是TCP保鲜定时器。当网络两端建立了TCP连接之后，闲置idle（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对对方的ack,如果一直没有收到对方的ack,一共会尝试tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。</p>
<p><strong>2. syn cookies设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure>

<p>在CentOS5.3中，该选项默认值是1，即启用syn cookies功能。我们建议先关闭，直到确定受到syn flood攻击的时候再开启syn cookies功能，有效地防止syn flood攻击。也可以通过<a target="_blank" rel="noopener" href="http://man.linuxde.net/iptables" title="iptables命令">iptables</a>规则拒绝syn flood攻击。</p>
<p><strong>3.TCP  连接建立设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 8192 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line">echo 2 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class="line">echo 2 &gt; /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure>

<p>tcp_max_syn_backlog  SYN队列的长度，时常称之为未建立连接队列。系统内核维护着这样的一个队列，用于容纳状态为SYN_RESC的TCP连接(half-open connection),即那些依然尚未得到客户端确认(ack)的TCP连接请求。加大该值，可以容纳更多的等待连接的网络连接数。</p>
<p>tcp_syn_retries  新建TCP连接请求，需要发送一个SYN包，该值决定内核需要尝试发送多少次syn连接请求才决定放弃建立连接。默认值是5. 对于高负责且通信良好的物理网络而言，调整为2</p>
<p>tcp_synack_retries  对于远端SYN连接请求，内核会发送SYN+ACK数据包来确认收到了上一个SYN连接请求包，然后等待远端的确认(ack数据包）。该值则指定了内核会向远端发送tcp_synack_retires次SYN+ACK数据包。默认设定值是5，可以调整为2</p>
<p><strong>4. TCP 连接断开相关设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo 30 &gt;  /proc/sys/net/ipv4/tcp_fin_timeout</span><br><span class="line">echo 15000 &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</span><br><span class="line">echo 1 &gt;  /proc/sys/net/ipv4/tcp_tw_recycle</span><br></pre></td></tr></table></figure>

<p>tcp_fin_timeout 对于由本端主动断开连接的TCP连接，本端会主动发送一个FIN数据报，在收到远端ACK后,且并没有收到远端FIN包之前，该TCP连接的状态是FIN_WAIT_2状态，此时当远端关闭了应用，网络不可达（拔网张），程序不可断僵死等等，本端会一直保留状态为FIN_WAIT_2状态的TCP连接，该值tcp_fin_timeout则指定了状态为FIN_WAIT_2的TCP连接保存多长时间，一个FIN_WAIT_2的TCP连接最多占1.5k内存。系统默认值是60秒，可以将此值调整为30秒，甚至10秒。</p>
<p>tcp_max_tw_buckets 系统同时处理TIME_WAIT sockets数目。如果一旦TIME_WAIT tcp连接数超过了这个数目，系统会强制清除并且显示警告消息。设立该限制，主要是防止那些简单的DoS攻击，加大该值有可能消耗更多的内存资源。如果TIME_WAIT socket过多，则有可能耗尽内存资源。默认值是18w,可以将此值设置为5000~30000<br>tcp_tw_resue 是否可以使用TIME_WAIT tcp连接用于建立新的tcp连接。</p>
<p>tcp_tw_recycle 是否开启快带回收TIME_WAIT tcp连接的功能。</p>
<p><strong>5. tcp 内存资源使用相参数设定</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo 16777216 &gt; /proc/sys/net/core/rmem_max</span><br><span class="line">echo 16777216 &gt; /proc/sys/net/core/wmem_max</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_mem</span><br><span class="line">echo “4096 65536 16777216″ &gt; /proc/sys/net/ipv4/tcp_rmem</span><br><span class="line">echo “4096 87380 16777216″ &gt; /proc/sys/net/ipv4/tcp_wmem</span><br></pre></td></tr></table></figure>

<p>rmem_max 定义了接收窗口可以使用的最大值，可以根据BDP值进行调节。<br>wmem_max 定义了发送窗口可以使用的最大值，可以根据BDP什值进行调整。<br>tcp_mem [low, pressure, high] TCP用这三个值来跟踪内存使用情况，来限定资源占用。通常情况下，在系统boot之时，内核会根据可用内存总数计算出这些值。如果出现了Out of socket memory,则可以试着修改这个参数。<br>1)low: 当TCP使用了低于该值的内存页面数时，TCP不会考滤释放内存。<br>2)pressure: 当TCP使用了超过该值的内存页面数量，TCP试图稳定其对内存的占用，进入pressure模式,直到内存消耗达于low值，退出该模式。<br>3)hight:允许所有tcp sockets用于排队缓冲数据报的内存页数。<br>tcp_rmem [min, default, max]<br>1)min 为每个TCP连接(tcp socket)预留用于接收缓冲的内存数量，即使在内存出现紧张情况下TCP socket都至少会有这么多数量的内存用于接收缓冲。<br>2)default 为TCP socket预留用于接收缓冲的内存数量，默认情况下该值影响其它协议使用的 rmem_default的值，所以有可能被rmem_default覆盖。<br>3)max 该值为每个tcp连接(tcp socket)用于接收缓冲的内存最大值。该值不会影响wmem_max的值，设置了选项参数 SO_SNDBUF则不受该值影响。<br>tcp_wmem [min, default, max] 如上(tcp_rmen)只不过用于发送缓存。</p>
<p>注:<br>1)可以通过<a target="_blank" rel="noopener" href="http://man.linuxde.net/sysctl" title="sysctl命令">sysctl</a> -<a target="_blank" rel="noopener" href="http://man.linuxde.net/w" title="w命令">w</a> 或者写入&#x2F;etc&#x2F;sysctl.conf永久保存<br>2)性能调优仅在于需要的时候进行调整，调整以后需要采集数据与基准测试数据进行比较。建议，不需要盲从地调整这些参数。</p>
<p>CLOSE_WAIT，TCP的癌症，TCP的朋友。<br>CLOSE_WAIT状态的生成原因<br>首先我们知道，如果我们的服务器程序APACHE处于CLOSE_WAIT状态的话，说明套接字是被动关闭的！<br>因为如果是CLIENT端主动断掉当前连接的话，那么双方关闭这个TCP连接共需要四个packet：<br>      Client —&gt;  FIN  —&gt;  Server<br>      Client &lt;—  ACK  &lt;—  Server<br>这时候Client端处于FIN_WAIT_2状态；而Server 程序处于CLOSE_WAIT状态。<br>      Client &lt;—  FIN  &lt;—  Server<br>这时Server 发送FIN给Client，Server 就置为LAST_ACK状态。<br>       Client —&gt;  ACK  —&gt;  Server<br>Client回应了ACK，那么Server 的套接字才会真正置为CLOSED状态。<br>Server 程序处于CLOSE_WAIT状态，而不是LAST_ACK状态，说明还没有发FIN给Client，那么可能是在关闭连接之前还有许多数据要发送或者其他事要做，导致没有发这个FIN packet。<br>通常来说，一个CLOSE_WAIT会维持至少2个小时的时间。如果有个流氓特地写了个程序，给你造成一堆的CLOSE_WAIT，消耗<br>你的资源，那么通常是等不到释放那一刻，系统就已经解决崩溃了。<br>只能通过修改一下TCP&#x2F;IP的参数，来缩短这个时间：修改tcp_keepalive_*系列参数有助于解决这个问题。<br>proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;下各项的意义<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_timeexceed_rate<br>这个在traceroute时导致著名的“Solaris middle star”。这个文件控制发送ICMP Time Exceeded消息的比率。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;igmp_max_memberships<br>主机上最多有多少个igmp (多播)套接字进行监听。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;inet_peer_gc_maxtime<br>求 助: Add a little explanation about the inet peer storage? Minimum interval between garbage collection passes. This interval is in effect under low (or absent) memory pressure on the pool. Measured in jiffies.<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;inet_peer_gc_mintime<br>每一遍碎片收集之间的最小时间间隔。当内存压力比较大的时候，调整这个间隔很有效。以jiffies计。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;inet_peer_maxttl<br>entries的最大生存期。在pool没有内存压力的情况下(比如，pool中entries的数量很少的时候)，未使用的entries经过一段时间就会过期。以jiffies计。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;inet_peer_minttl<br>entries的最小生存期。应该不小于汇聚端分片的生存期。当pool的大小不大于inet_peer_threshold时，这个最小生存期必须予以保证。以jiffies计。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;inet_peer_threshold<br>The approximate size of the INET peer storage. Starting from this threshold entries will be thrown aggressively. This threshold also determines entries’ time-to-live anｄ time intervals between garbage collection passes. More entries, less time-to-live, less GC interval.<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_autoconfig<br>这个文件里面写着一个数字，表示主机是否通过RARP、BOOTP、DHCP或者其它机制取得其IP配置。否则就是0。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_default_ttl<br>数据包的生存期。设置为64是安全的。如果你的网络规模巨大就提高这个值。不要因为好玩而这么做??那样会产生有害的路由环路。实际上，在很多情况下你要考虑能否减小这个值。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_dynaddr&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_destunreach_rate<br>如果你有一个动态地址的自动拨号接口，就得设置它。当你的自动拨号接口激活的时候，本地所有没有收到答复的TCP套接字会重新绑定到正确的地址上。这可以解决引发拨号的套接字本身无法工作，重试一次却可以的问题。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward<br>内核是否转发数据包。缺省禁止。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_local_port_range<br>用于向外连接的端口范围。缺省情况下其实很小：1024到4999。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_no_pmtu_disc<br>如果你想禁止“沿途MTU发现”就设置它。“沿途MTU发现”是一种技术，可以在传输路径上检测出最大可能的MTU值。参见Cookbook一章中关于“沿途MTU发现”的内容。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ipfrag_high_thresh<br>用 于IP分片汇聚的最大内存用量。分配了这么多字节的内存后，一旦用尽，分片处理程序就会丢弃分片。When ipfrag_high_thresh bytes of memory is allocated for this purpose, the fragment handler will toss packets until ipfrag_low_thresh is reached.<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_nonlocal_bind<br>如果你希望你的应用程序能够绑定到不属于本地网卡的地址上时，设置这个选项。如果你的机器没有专线连接(甚至是动态连接)时非常有用，即使你的连接断开，你的服务也可以启动并绑定在一个指定的地址上。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ipfrag_low_thresh<br>用于IP分片汇聚的最小内存用量。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ipfrag_time<br>IP分片在内存中的保留时间(秒数)。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_abort_on_overflow<br>一个布尔类型的标志，控制着当有很多的连接请求时内核的行为。启用的话，如果服务超载，内核将主动地发送RST包。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout<br>如 果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。参见tcp_max_orphans。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_time<br>当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_intvl<br>当探测没有确认时，重新发送探测的频度。缺省是75秒。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_probes<br>在认定连接失效之前，发送多少个TCP的keepalive探测包。缺省值是9。这个值乘以tcp_keepalive_intvl之后决定了，一个连接发送了keepalive之后可以有多少时间没有回应。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_orphans<br>系 统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单 的DoS攻击，你绝对不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。This limit exists only to prevent simple DoS attacks, you _must_ not rely on this oｒ lower the limit artificially, but rather increase it (probably, after increasing installed memory), if network conditions require more than default value, anｄ tune network services to linger anｄ kill such states more aggressively. 让我再次提醒你：每个孤儿套接字最多能够吃掉你64K不可交换的内存。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_orphan_retries<br>本端试图关闭TCP连接之前重试多少次。缺省值是7，相当于50秒<del>16分钟(取决于RTO)。如果你的机器是一个重载的WEB服务器，你应该考虑减低这个值，因为这样的套接字会消耗很多重要的资源。参见tcp_max_orphans。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog<br>记 录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。如果服务器不堪重负，试 试提高这个值。注意！如果你设置这个值大于1024，最好同时调整include&#x2F;net&#x2F;tcp.h中的TCP_SYNQ_HSIZE，以保证 TCP_SYNQ_HSIZE*16 ≤tcp_max_syn_backlo，然后重新编译内核。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_tw_buckets<br>系 统同时保持timewait套接字的最大数量。如果超过这个数字，time-wait套接字将立刻被清除并打印警告信息。这个限制仅仅是为了防止简单的 DoS攻击，你绝对不能过分依靠它或者人为地减小这个值，如果网络实际需要大于缺省值，更应该增加这个值(如果增加了内存之后)。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retrans_collapse<br>为兼容某些糟糕的打印机设置的“将错就错”选项。再次发送时，把数据包增大一些，来避免某些TCP协议栈的BUG。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries1<br>在认定出错并向网络层提交错误报告之前，重试多少次。缺省设置为RFC规定的最小值：3，相当于3秒</del>8分钟（取决于RIO）。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries2<br>在杀死一个活动的TCP连接之前重试多少次。RFC 1122规定这个限制应该长于100秒。这个值太小了。缺省值是15，相当于13~30分钟（取决于RIO）。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_rfc1337<br>这个开关可以启动对于在RFC1337中描述的“tcp的time-wait暗杀危机”问题的修复。启用后，内核将丢弃那些发往time-wait状态TCP套接字的RST包。却省为0。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_sack<br>特别针对丢失的数据包使用选择性ACK，这样有助于快速恢复。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_stdurg<br>使用TCP紧急指针的主机需求解释。因为绝大多数主机采用BSD解释，所以如果你在Linux上打开它，可能会影响它与其它机器的正常通讯。缺省是FALSE。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries<br>在内核放弃建立连接之前发送SYN包的数量。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_synack_retries<br>为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN ACK包的数量。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_timestamps<br>时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_tw_recycle<br>能够更快地回收TIME-WAIT套接字。缺省值是1。除非有技术专家的建议和要求，否则不应修改。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_window_scaling<br>一般来说TCP&#x2F;IP允许窗口尺寸达到65535字节。对于速度确实很高的网络而言这个值可能还是太小。这个选项允许设置上G字节的窗口大小，有利于在带宽*延迟很大的环境中使用。<br>一旦内核认为它无法发包，就会丢弃这个包，并向发包的主机发送ICMP通知。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all<br>根本不要响应echo包。请不要设置为缺省，它可能在你正被利用成为DoS攻击的跳板时可能有用。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_broadcasts [Useful]<br>如果你ping子网的子网地址，所有的机器都应该予以回应。这可能成为非常好用的拒绝服务攻击工具。设置为1来忽略这些子网广播消息。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echoreply_rate<br>设置了向任意主机回应echo请求的比率。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_ignore_bogus_error_responses<br>设置它之后，可以忽略由网络中的那些声称回应地址是广播地址的主机生成的ICMP错误。<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_paramprob_rate<br>一个相对不很明确的ICMP消息，用来回应IP头或TCP头损坏的异常数据包。你可以通过这个文件控制消息的发送比率。<br>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p><a target="_blank" rel="noopener" href="http://skylove.study-area.org/blog/2006/07/linuxip/_29.html">http://skylove.study-area.org/blog/2006/07/linuxip\_29.html</a></p>
<p>tcp_syn_retries ：INTEGER<br>默认值是5<br>对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅 仅是针对对外的连接,对进来的连接,是由tcp_retries1 决定的)<br>tcp_synack_retries ：INTEGER<br>默认值是5<br>对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。(可以根据上面的 tcp_syn_retries 来决定这个值)<br>tcp_keepalive_time ：INTEGER<br>默认值是7200(2小时)<br>当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu 的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst&#x2F;fin消息,那么持续的时间是不是就是2小时,空连接攻击? tcp_keepalive_time就是预防此情形的.我个人在做nat服务的时候的修改值为1800秒)<br>tcp_keepalive_probes：INTEGER<br>默认值是9<br>TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适)<br>tcp_keepalive_intvl：INTEGER<br>默认值为75<br>探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动 的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的 值)<br>tcp_retries1 ：INTEGER<br>默认值是3<br>放弃回应一个TCP连接请求前?需要进行多少次重试。RFC 规定最低的数值是3?这也是默认值?根据RTO的值大约在3秒 – 8分钟之间。(注意:这个值同时还决定进入的syn连接)<br>tcp_retries2 ：INTEGER<br>默认值为15<br>在丢弃激活(已建立通讯状况)的TCP连接之前?需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)<br>tcp_orphan_retries ：INTEGER<br>默认值是7<br>在近端丢弃TCP连接之前?要进行多少次重试。默认值是7个?相当于 50秒 – 16分钟?视 RTO 而定。如果您的系统是负载很大的web服务器?那么也许需要降低该值?这类 sockets 可能会耗费大量的资源。另外参的考 tcp_max_orphans 。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)<br>tcp_fin_timeout ：INTEGER<br>默认值是 60<br>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。过去在2.2版本的内核中是 180 秒。您可以设置该值?但需要注意?如果您的机器为负载很重的web服务器?您可能要冒内存被大量无效数据报填满的风险?FIN-WAIT-2 sockets 的危险性低于 FIN-WAIT-1 ?因为它们最多只吃 1.5K 的内存?但是它们存在时间更长。另外参考 tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为30)<br>tcp_max_tw_buckets ：INTEGER<br>默认值是180000<br>系 统在同时所处理的最大 timewait sockets 数目。如果超过此数的话?time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制?纯粹为了抵御那些简单的 DoS 攻击?千万不要人为的降低这个限制?不过?如果网络条件需要比默认值更多?则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加 该值)<br>tcp_tw_recycle ：BOOLEAN<br>默认值是0<br>打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求?请不要随意修改这个值。(做NAT的时候，建议打开它)<br>tcp_tw_reuse：BOOLEAN<br>默认值是0<br>该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)<br>tcp_max_orphans ：INTEGER<br>缺省值是8192<br>系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量?那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制?纯粹为了抵御那些 简单的 DoS 攻击?千万不要依赖这个或是人为的降低这个限制(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)<br>tcp_abort_on_overflow ：BOOLEAN<br>缺省值是0<br>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。 只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这 个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)<br>tcp_syncookies ：BOOLEAN<br>默认值是0<br>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。<br>注意：该选项千万不能用于那些没有收到攻击的高负载服务器，如果在日志中出现synflood消息，但是调查发现没有收到synflood攻击，而是合法用户的连接负载过高的原因，你应该调整其它参数来提高服务器性能。参考:<br>tcp_max_syn_backlog<br>tcp_synack_retries<br>tcp_abort_on_overflow<br>syncookie严重的违背TCP协议，不允许使用TCP扩展，可能对某些服务导致严重的性能影响(如SMTP转发)。(注意,该实现与BSD上面使用 的tcp proxy一样,是违反了RFC中关于tcp连接的三次握手实现的,但是对于防御syn-flood的确很有用.)<br>tcp_stdurg ：BOOLEAN<br>默认值为0<br>使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在 Linux 打开它?或会导致不能和它们正确沟通。<br>tcp_max_syn_backlog ：INTEGER<br>对于那些依然还未获得客户端确认的连接请求?需要保存在队列中最大数目。对于超过 128Mb 内存的系统?默认值是 1024 ?低于 128Mb 的则为 128。如果服务器经常出现过载?可以尝试增加这个数字。警告?假如您将此值设为大于 1024?最好修改 include&#x2F;net&#x2F;tcp.h 里面的 TCP_SYNQ_HSIZE ?以保持 TCP_SYNQ_HSIZE*16&lt;&#x3D;tcp_max_syn_backlog ?并且编进核心之内。(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗 尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完 全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies&#x2F;Caches)联合应用时，能够比较有 效的缓解小规模的SYN Flood攻击(事实证明&lt;1000p&#x2F;s)加大SYN队列长度可以容纳更多等待连接的网络连接数，所以对Server来说可以考虑增大该值.)<br>tcp_window_scaling ：INTEGER<br>缺省值为1<br>该 文件表示设置tcp&#x2F;ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp&#x2F;ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp&#x2F;ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）<br>tcp_timestamps ：BOOLEAN<br>缺省值为1<br>Timestamps 用在其它一些东西中?可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)<br>tcp_sack ：BOOLEAN<br>缺省值为1<br>使 用 Selective ACK?它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个 选项应该启用，但是这会增加对 CPU 的占用。)<br>tcp_fack ：BOOLEAN<br>缺省值为1<br>打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)<br>tcp_dsack ：BOOLEAN<br>缺省值为1<br>允许TCP发送”两个完全相同”的SACK。<br>tcp_ecn ：BOOLEAN<br>缺省值为0<br>打开TCP的直接拥塞通告功能。<br>tcp_reordering ：INTEGER<br>默认值是3<br>TCP流中重排序的数据报最大数量 。 (一般有看到推荐把这个数值略微调整大一些,比如5)<br>tcp_retrans_collapse ：BOOLEAN<br>缺省值为1<br>对于某些有bug的打印机提供针对其bug的兼容性。(一般不需要这个支持,可以关闭它)<br>tcp_wmem(3个INTEGER变量)： min, default, max<br>min：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)。<br>default：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为16384(16K)。<br>max: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，”静态”选择参数SO_SNDBUF则不受该值影响。默认值为 131072(128K)。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800）<br>tcp_rmem (3个INTEGER变量)： min, default, max<br>min：为TCP socket预留用于接收缓冲的内存数量，即使在内存出现紧张情况下tcp socket都至少会有这么多数量的内存用于接收缓冲，默认值为8K。<br>default：为TCP socket预留用于接收缓冲的内存数量，默认情况下该值影响其它协议使用的 net.core.wmem_default 值。该值决定了在tcp_adv_win_scale、tcp_app_win和tcp_app_win&#x3D;0默认值情况下，TCP窗口大小为65535。 默认值为87380<br>max：用于TCP socket接收缓冲的内存最大值。该值不会影响 net.core.wmem_max，”静态”选择参数 SO_SNDBUF则不受该值影响。默认值为 128K。默认值为87380*2 bytes。（可以看出，.max的设置最好是default的两倍,对于NAT来说主要该增加它,我的网络里为 51200 131072 204800）<br>tcp_mem(3个INTEGER变量)：low, pressure, high<br>low：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 – 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 * 300 &#x2F; 4096)。 )<br>pressure：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出 pressure状态。(理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 (204800 * 300 &#x2F; 4096)。 )<br>high：允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 (512000 * 300 &#x2F; 4096) 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000)<br>一般情况下这些值是在系统启动时根据系统内存数量计算得到的。<br>tcp_app_win : INTEGER<br>默认值是31<br>保留max(window&#x2F;2^tcp_app_win, mss)数量的窗口由于应用缓冲。当为0时表示不需要缓冲。<br>tcp_adv_win_scale : INTEGER<br>默认值为2<br>计算缓冲开销bytes&#x2F;2^tcp_adv_win_scale(如果tcp_adv_win_scale &gt; 0)或者bytes-bytes&#x2F;2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale &lt;&#x3D; 0）。<br>tcp_rfc1337 :BOOLEAN<br>缺省值为0<br>这个开关可以启动对于在RFC1337中描述的”tcp 的time-wait暗杀危机”问题的修复。启用后，内核将丢弃那些发往time-wait状态TCP套接字的RST 包.<br>tcp_low_latency : BOOLEAN<br>缺省值为0<br>允许 TCP&#x2F;IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用。(但在构建Beowulf 集群的时候,打开它很有帮助)<br>tcp_westwood :BOOLEAN<br>缺省值为0<br>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN 通信来说应该启用这个选项。<br>tcp_bic :BOOLEAN<br>缺省值为0<br>为快速长距离网络启用 Binary Increase Congestion；这样可以更好地利用以 GB 速度进行操作的链接；对于 WAN 通信应该启用这个选项。<br># 以下一段为抵抗syn flood攻击，平时建议关闭<br>sysctl -w net.ipv4.tcp_syncookies&#x3D;1              # tcp syncookie，默认关闭<br>sysctl -w net.ipv4.tcp_max_syn_backlog&#x3D;1280   # syn队列，默认1024，&gt; 1280可能工作不稳定，需要修改内核源码参数<br>sysctl -w net.ipv4.tcp_synack_retries&#x3D;2             # syn-ack握手状态重试次数，默认5，遭受syn-flood攻击时改为1或2<br>sysctl -w net.ipv4.tcp_syn_retries&#x3D;2                  # 外向syn握手重试次数，默认4<br># 以下一段为应对tcp connect连接耗尽攻击，如果开启iptables connlimit模块可禁用<br># 有严重连接性能影响和不稳定因素，慎用<br>sysctl -w tcp_tw_recycle&#x3D;1                           # 默认0，tw快速回收<br>sysctl -w tcp_tw_reuse&#x3D;1                             # 默认0，tw重用<br>sysctl -w tcp_keepalive_intvl&#x3D;60                    # 默认75，tcp keeplive探测轮询时间<br>sysctl -w tcp_keepalive_probes&#x3D;3                  # 默认9，tcp keeplive探测轮询次数<br>sysctl -w tcp_keepalive_time&#x3D;1800                # 默认7200，tcp keeplive时间<br>sysctl -w tcp_fin_timeout&#x3D;30                        # 默认60，tcp fin状态超时时间<br>#sysctl -w net.ipv4.tcp_retries1&#x3D;2                     # tcp连接重传参数，慎用<br>#sysctl -w net.ipv4.tcp_retries2&#x3D;8<br>sysctl -w net.ipv4.ip_conntrack_max&#x3D;65535          # 增大iptables状态跟踪表</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/10/16/Linux-TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/10/12/Zabbix%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Zabbix安装包下载地址</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> JinTao Li
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="https://beian.miit.gov.cn/" target="_black" rel="nofollow">鲁ICP备88888888</a>
        </li>
        
    </ul>
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">青岛公安网备01234567890123号</a>
      </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Lijintao&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/u013235026">CSDN</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.cnblogs.com/jintaoli">博客园</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/images/272a163694dd8a415a43dbf85ac34778.jpg">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=2142256392&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "jintao1210";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "请输入访问密码",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "确定",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "密码错误，请重试",
            confirmButtonText: "确定",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>