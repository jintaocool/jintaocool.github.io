<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="博客" />
       
      <meta name="description" content="日常随笔" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Prometheus Query Language |  Lijintao&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Lijintao's Blog" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="Prometheus-Prometheus-Query-Language"
  class="article article-type-Prometheus"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Prometheus Query Language
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/06/07/Prometheus-Query-Language/" class="article-date">
  <time datetime="2024-06-07T05:41:47.000Z" itemprop="datePublished">2024-06-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Prometheus/">Prometheus</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">30 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>　　Prometheus 内置了自己的功能表达式查询语言——PromQL(Prometheus Query Language)。它允许用户实时选择和汇聚时间序列数据，从而很方便地在 Prometheus 中查询和检索数据。表达式的结果可以在浏览器中展示位图形，也可以展示位表格，或者由外部系统通过 HTTP API 的形式进行调用。虽然 PromQL 这个单词以 QL 结尾，但是它并不是一种与 SQL 类似的语言，因为当涉及在时间序列上执行计算时，SQL 往往缺乏必要的表达能力。</p>
<p>　　PromQL 的表现力非常强，除了支持常见的操作符外，还提供了大量的内置函数来实现对数据的高级处理，让监控的数据会说话。日常数据查询、可视化及告警配置这三大功能模块都是依赖 PromQL 实现的。</p>
<p>　　PromQL 是 Prometheus 实战的核心，是 Prometheus 场景的基础，也是 Prometheus 的必修课。</p>
<h2 id="一、初识-PromQL"><a href="#一、初识-PromQL" class="headerlink" title="一、初识 PromQL"></a>一、初识 PromQL</h2><p>　　我们先通过案例来看看 PromQL，感受下 PromQL 是如何让用户通过指标更好地了解系统的性能的。</p>
<p>　　<strong>案例一：获取当前主机可用的内存空间大小，单位 MB。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes_total / (1024 * 1024)</span><br></pre></td></tr></table></figure>

<p>　　说明：node_memory_free_bytes_total 是瞬时向量表达式，返回的结果是瞬时向量。它可以用于获取当前主机可用的内存大小，默认的样本单位是 B，我们需要将单位换算为 MB。</p>
<p>　　<strong>案例二：基于 2 小时的样本数据，预测未来 24 小时内磁盘是否会满。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if predict_linear(node_filesystem_free[2h],24*3600) &lt; 0 </span><br></pre></td></tr></table></figure>

<p>　　说明：predict_linear(v range-vector,t scalar) 函数可以预测时间序列 v 在 t 秒后的值，它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而对时间序列的变化趋势做出预测。上述命令就是根据文件系统过去2小时以内的空闲磁盘，去计算未来24小时磁盘空间是否会小鱼0.如果用户需要基于这个线性预测函数增加告警功能，也可以按如下方式扩展更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALERT DiskWillFullIn24Houre</span><br><span class="line">    IF predict_linear(node_filesystem_free[2h],24*3600)&lt;0</span><br></pre></td></tr></table></figure>

<p>　　<strong>案例三：http_request_total（HTTP 请求总数）的 9 种常见 PromQL 语句。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查询 HTTP 请求总数。</span><br><span class="line">http_requests_total</span><br><span class="line"></span><br><span class="line"># 2.查询返回所有时间序列、指标 http_requests_total,以及给定 job 和 handler 的标签</span><br><span class="line">http_requests_total&#123;job=&quot;apiserver&quot;,handle=&quot;/api/comments&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 3.条件查询：查询状态码为 200 的请求总数。</span><br><span class="line">http_requests_total&#123;code=&quot;200&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 4.区间查询：查询5分钟内的请求总量</span><br><span class="line">http_requests_total&#123;&#125;[5m]</span><br><span class="line"></span><br><span class="line"># 5.系统函数使用</span><br><span class="line"># 查询系统所有 HTTP 请求的总量</span><br><span class="line">sum(http_requests_total)</span><br><span class="line"></span><br><span class="line"># 6.使用正则表达式，选择名称与特定模式匹配的作业（如以 server 结尾的作业）的时间序列</span><br><span class="line">http_requests_total&#123;job=~&quot;.&quot;server&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 7.过滤除了 4xx 之外所有 HTTP 状态码的数据</span><br><span class="line">http_requests_total&#123;status!~&quot;4..&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 8.子查询，以1次/分钟的速率采集最近30分钟内的指标数据，然后返回这30分钟内距离当前时间</span><br><span class="line"># 最近的5分钟内的采集结果</span><br><span class="line">rate(http_requests_total[5m])[30m:1m]</span><br><span class="line"></span><br><span class="line"># 9.函数 rate，以1次/秒的速度采集最近5分钟内的数据并将结果以时间序列的形式返回</span><br><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure>

<p>　　如上所述，我们仅针对 http_requests_total 这一个指标就做了9种不同的具有代表性的监控按理，可以看出 PromQL 语句是非常灵活的。</p>
<h3 id="1-1-PromQL-的4种数据类型"><a href="#1-1-PromQL-的4种数据类型" class="headerlink" title="1.1  PromQL 的4种数据类型"></a>1.1  PromQL 的4种数据类型</h3><p>　　结合上述案例，我们看到了瞬时向量 Instant vector 和区间向量 Ranger vector，它们属于 Prometheus 表达式语言的4种数据类型。</p>
<p>1、瞬时向量(Instant vector)：一组时间序列，每个时间序列包含单个样本，它们共享相同的时间戳。也就是说，表达式的返回值中只会包含该时间序列中的最新的一个样本值。而相应的这样的表达式称之为瞬时向量表达式。</p>
<p>2、区间向量(Range vector)：一组时间序列，每个时间序列包含一段时间范围内的样本数据。</p>
<p>3、标量(Scalar)：一个浮点型的数据值。</p>
<p>4、字符串(String)： 一个简单的字符串值。</p>
<h3 id="1-2-时间序列"><a href="#1-2-时间序列" class="headerlink" title="1.2 时间序列"></a>1.2 时间序列</h3><p>　　和MySQL 关系型数据库不同的是，时间序列数据库主要按照一定的时间间隔产生一个个数据点，而这些数据点按照时间戳和值的生成顺序存放，这就得到了我们上问提到的向量(vector)。以时间轴为横坐标、序列为纵坐标，这些数据点连接起来就会形成一个矩阵。</p>
<p>　　矩阵中的每一个点都可称为一个样本(Sample)，样本主要由3方面构成。</p>
<ul>
<li><ul>
<li>指标(Metrics)：包括指标名称(Metrics name)和一组标签集(Label set)名称，如 request_total{path&#x3D;”&#x2F;status”,method&#x3D;”GET”}。</li>
<li>时间戳(TimeStamp)：这个值默认精确到毫秒。</li>
<li>样本值(Value)：这个值默认使用 Float64 浮点类型。</li>
</ul>
</li>
</ul>
<p>　　Prometheus 会定期为所有系列收集新数据点。</p>
<h3 id="1-3-指标"><a href="#1-3-指标" class="headerlink" title="1.3 指标"></a>1.3 指标</h3><p>　　时间序列的指标（Metrics）可以基于 Bigtable（Google 论文）设计为 Key-Value 存储方式，如下图所示</p>
<p><img src="/images/1717738836-beedea869f85ae1f7a457ce7dd0c4768.png"></p>
<p>　　上图中的 http_requests_total{status&#x3D;”401”,method&#x3D;”GET”}  @1434317560938   94358 为例，在 Key-value中，94358 作为 Value（也就是样本值 Sample Value），前面的 http_requests_total{status&#x3D;”401”,method&#x3D;”GET”}   @1434317560938 一律为 Key。在 Key 中，又由 Metrics Name（例子中的 http_requests_total）、Label（例子中的{status&#x3D;”401”,method&#x3D;”GET”}）和 Timestamp（例子中的 @1434317560938）3部分构成。</p>
<p>　　在 Prometheus 的世界里，所有的数值都是 64 bit的。每条时间序列里面记录的就是 64 bit Timestamp（时间戳）和 64 bit 的 Sample Value（采样值）。</p>
<p><img src="/images/1717738836-37fe3ea80861f4bf3906fafb9f13e404.png"></p>
<p>　　如图所示，Prometheus 的 Metrics 可以有两种表现方式。第一种方式是经典的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Metric Name&gt;&#123;&lt;Label name&gt;=&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure>

<p>　　其中，Metric Name 就是指标名称，反映监控样本的含义。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式[a-zA-Z_:][a-zA-Z0-9_:]*。</p>
<p>　　标签反映了当前样本的多种特征纬度。通过这些纬度，Prometheus 可以对样本数据进行过滤、聚合、统计等操作，从而产生新的计算后的一条时间序列。标签名称也只能由ASCII字符、数字以及下划线组成，并且必须满足正则表达式[a-zA-Z_][a-zA-Z0-9_]*。</p>
<p>　　通过命令 go_gc_duration_seconds{quantile&#x3D;”0”} 可以在 Prometheus 的 Graph控制台获得图：</p>
<p><img src="/images/1717738836-1187190bf0082e0d3d918e2d1c4db54e.png"></p>
<p>　　第二种方式来源于 Prometheus 内部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　(__name__=metrics.&lt;label name&gt;=&lt;label value&gt;, ...)</span><br></pre></td></tr></table></figure>

<p>　　第二种方式和第一种方式是一样的，表示同一条时间序列。这种方式是 Prometheus 内部的表现形式，是系统保留的关键字，官方推荐只能在系统内部使用。在 Prometheus 的底层实现中，指标名称实际上是以 __name__&#x3D;<metric name> 的形式保存在数据库中的；__name__ 是特定的标签，代表了 Metric Name。标签的值可以包含任何 Unicode 编码的字符。</p>
<p>　　通过命令 {__name__&#x3D;”go_gc_duration_seconds”,quantile&#x3D;”0”} 可以在 Prometheus 的 Graph 控制台获得如下结果：</p>
<p><img src="/images/1717738836-674da26e7a4ac9842d06882713ebe921.png"></p>
<h2 id="二、PromQL中的4大选择器"><a href="#二、PromQL中的4大选择器" class="headerlink" title="二、PromQL中的4大选择器"></a>二、PromQL中的4大选择器</h2><p>　　如果一个指标来自多个不同类型的服务器或者应用，那么技术人员通常都有缩小范围的需求，例如希望从不计其数的指标中查看来自一个实例 instance 或者 handler 标签的指标。这时就要用标签筛选功能了。这种标签的筛选功能是通过选择器（Selector）来完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;Helloworld&quot;,status=&quot;200&quot;,method=&quot;POST&quot;,handler=&quot;/api/comments&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>　　这就是一个选择器，它返回的 job 是 HelloWorld，返回值是 200，方法是 POST(handler 标签为 “&#x2F;api&#x2F;comments” 的 http_requests_total)。它是 HTTP 请求总数的瞬时向量选择器(InstantVector Selector)。</p>
<p>　　例子中的 job&#x3D;”HelloWorld”是一个匹配器(Matcher)，一个选择器中可以有多个匹配器，它们组合在一起使用。</p>
<p>　　接下来就从匹配器（Matcher）、瞬时向量选择器（Instant Vector Selector）、区间向量选择器（Range Vector Selector）和偏移量修改器（Offset）这4个方面对 PromQL 进行介绍。</p>
<h3 id="2-1-匹配器"><a href="#2-1-匹配器" class="headerlink" title="2.1 匹配器"></a>2.1 匹配器</h3><p>　　匹配器是作用于标签上的，标签匹配器可以对时间序列进行过滤，Prometheus 自持完全匹配和正则匹配两种模式。</p>
<h4 id="2-1-1-相等匹配器（-）"><a href="#2-1-1-相等匹配器（-）" class="headerlink" title="2.1.1. 相等匹配器（&#x3D;）"></a>2.1.1. 相等匹配器（&#x3D;）</h4><p>　　相等匹配器（Equality Matcher），用于选择与提供的字符串完全相同的标签。下面介绍的例子中就会使用相等匹配器按照条件进行一系列过滤。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;Helloworld&quot;,status=&quot;200&quot;,method=&quot;POST&quot;,handler=&quot;/api/comments&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>　　需要注意的是，如果标签为空或者不存在，那么也可以使用 Label&#x3D;”” 的形式。对于不存在的标签，比如 demo 标签，go_gc_duration_seconds_count 和 go_gc_duration_seconds_count{demo&#x3D;””} 效果是一样的，对比如下：</p>
<p><img src="/images/1717738836-dce78fa028908518405769b2806c97da.png"></p>
<p><img src="/images/1717738836-d6e403b59285eca573c76c7daa573fe8.png"></p>
<h4 id="2-1-2-不相等匹配器（-）"><a href="#2-1-2-不相等匹配器（-）" class="headerlink" title="2.1.2. 不相等匹配器（!&#x3D;）"></a>2.1.2. 不相等匹配器（!&#x3D;）</h4><p>　　不相等匹配器（Negative Equality Matcher），用于选择与提供的字符串不相等的标签。它和相等匹配器是完全性相反的。举个例子，如果想要查看 job 并不是 HelloWorld 的 HTTP 请求总数，可以使用如下不相等匹配器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job!=&quot;HelloWorld&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-正则表达式匹配器（-）"><a href="#2-1-3-正则表达式匹配器（-）" class="headerlink" title="2.1.3. 正则表达式匹配器（&#x3D;~）"></a>2.1.3. 正则表达式匹配器（&#x3D;~）</h4><p>　　正则表达式匹配器（Regular Expression Matcher），用于选择与提供的字符串进行正则运算后所得结果相匹配的标签。Prometheus 的正则运算是强指定的，比如正则表达式 a 只会匹配到字符串 a，而并不会匹配到 ab 或者 ba 或者 abc。如果你不想使用这样的强制指定功能。可以在正则表达式的前面或者后面加上 “.*“。比如下面的例子表示 job 是所有以 Hello 开头的 HTTP 请求总数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=~&quot;Hello.*&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>　　http_requests_total 直接等效于 {__name__&#x3D;”http_requests_total”}，后者也可以使用和前者一样的4种匹配器（&#x3D;，！&#x3D;，&#x3D;~,!&#x3D;）。比如下面的例子表示 job 是所有以 Hello 开头的指标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name_-=~&quot;Hello.*&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果想要查看 job 是以 Hello 开头的，且在生产（prod）、测试（test）、预发布（pre）等环境下响应结果不是 200 的 HTTP 请求总数，可以使用这样的方式进行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;Hello.*&quot;,env=~&quot;prod|test|pre&quot;,code!=&quot;200&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>　　由于所有的 PromQL 表达式必须至少包含一个指标名称，或者至少有一个不会匹配到空字符串的标签过滤器，因此结合 Prometheus 官方文档，可以梳理出如下非法实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;job=~&quot;.*&quot;&#125;    #非法！</span><br><span class="line">&#123;job=&quot;&quot;&#125;       #非法！</span><br><span class="line">&#123;job!=&quot;&quot;&#125;      #非法！</span><br></pre></td></tr></table></figure>

<p>　　相反，如下表达式是合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;job=~&quot;.+&quot;&#125;                #合法！ .+ 表示至少一个字符</span><br><span class="line">&#123;job=~&quot;.*&quot;,method=&quot;get&quot;&#125;   #合法！ .* 表示任意一个字符</span><br><span class="line">&#123;job=~&quot;&quot;,method=&quot;post&quot;&#125;    #合法！ 存在一个非空匹配</span><br><span class="line">&#123;job=~&quot;.+&quot;，method=&quot;post&quot;&#125; #合法！ 存在一个非空匹配</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-正则表达式相反匹配器（-）"><a href="#2-1-4-正则表达式相反匹配器（-）" class="headerlink" title="2.1.4. 正则表达式相反匹配器（!~）"></a>2.1.4. 正则表达式相反匹配器（!~）</h4><p>　　正则表达式相反匹配器（Negative Regular Expression Matcher），用于选择与提供的字符串进行正则运算后所得结果不匹配的标签。因为 PromQL 的正则表达式基于 RE2 的语法，但是 RE2 不支持向前不匹配表达式，所以 !~ 的出现是一种替代方案，以实现基于正则表达式排除指定标签值的功能。在一个选择器当中，可以针对同一个标签来使用多个匹配器。比如下面的例子，可以实现查找 job 名是 node 且安装在 &#x2F;prometheus 目录下，但是并不在 &#x2F;prometheus&#x2F;user 目录下的所有文件系统并确定其大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_filesystem_size_bytes&#123;job=&quot;node&quot;,mountpoint=~&quot;/prometheus/.*&quot;,mountpoint !~ &quot;/prometheus/user/.*&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>　　PromQL 采用的是 RE2 引擎，支持正则表达式。RE2 来源于 Go 语言，它被设计为一种线性时间模式，非常适合用于 PromQL 这种时间序列的方法。但是就像我们前文描述的 RE2 那样，其不支持向前不匹配表达式(向前断言)，也不支持反向引用，同时还缺失很多高级特性。</p>
<hr>
<p> <strong>知识延伸：</strong></p>
<p>　　<strong>&#x3D;、!&#x3D;、</strong>=<del>、!</del> 这4个匹配器在实战中非常有用，但是如果频繁为标签施加正则匹配器，比如 HTTP 状态码有 1xx、2xx、3xx、4xx、5xx，在统计所有返回值是 5xx 的 HTTP 请求时，PromQL 语句就会变成 http_requests_total{job&#x3D;”HelloWorld”,status&#x3D;<del>“500”,status&#x3D;</del>“501”,status&#x3D;<del>“502”,status&#x3D;</del>“503”,status&#x3D;<del>“504”,status&#x3D;</del>“505”……}</p>
<p>　　但是，我们都知道 5xx 代表服务器错误，这些状态表示服务器在尝试处理请求时发生了内部错误。这些错误可能来自服务器本身，而不是请求。</p>
<p>　　500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>　　501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>　　502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>　　503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>　　504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>　　505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
<p>　　　　……</p>
<p>　　为了消化这样的错误，可以进行如下优化：</p>
<p>　　优化一：多个表达式之间使用 “|” 进行分割：http_requests_total{job&#x3D;”HelloWorld”,status&#x3D;~”500|501|502|503|504|505”}。</p>
<p>　　优化二：将这些返回值包装为 5xx，这样就可以直接使用正则表达式匹配器对 http_requests_total{job&#x3D;”HelloWorld”,status&#x3D;~”5xx”}进行优化。</p>
<p>　　优化三：如果要选择不以 4xx 开头的所有 HTTP 状态码，可以使用 http_requests_total{status!~”4..”}。</p>
<h3 id="2-2-瞬时向量选择器"><a href="#2-2-瞬时向量选择器" class="headerlink" title="2.2 瞬时向量选择器"></a>2.2 瞬时向量选择器</h3><p>　　瞬时向量选择器用于返回在指定时间戳之前查询到的最新样本的瞬时向量，也就是包含 0 个或者多个时间序列的列表。在最简单的形式中，可以仅指定指标的名称，如 http_requests_total，这将生成包含此指标名称的所有时间序列的元素的瞬时向量。我们可以通过大括号 {} 中添加一组匹配的标签来进一步过滤这些时间序列，如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;HelloWorld&quot;,group=&quot;middlueware&quot;&#125;</span><br><span class="line">http_requests_total&#123;&#125;    选择当前最新的数据</span><br></pre></td></tr></table></figure>

<p>　　瞬时向量并不希望获取过时的数据，这里需要注意的是，在 Prometheus 1.x 和 2.x 版本中是有区别的。</p>
<p>　　在 Prometheus 1.x 中会返回在查询时间之间不超过 5 分钟的时间序列，这种方法还是能满足大多数场景的需求的。但是如果在第一次查询，如 http_requests_total{job&#x3D;”HellWorld”} 这个5分钟的时间窗口内增加一个 label，如 http_requests_total{job&#x3D;”HelloWorld”,group&#x3D;”middleware”}，之后再重新进行一次瞬时查询，那么就会重复计费。这是一个问题。</p>
<p>　　在 Prometheus 2.x 是这么处理上述问题的：它会像汽车雨刮器一样刮擦，如果一个时间序列从一个刮擦到另一个，或者 Prometheus 的服务发现不再能找到当前 target，陈旧的标记就会被添加到时间序列中。这时使用瞬时向量过滤器，除需要找到满足匹配条件的时间序列之外，还需要考虑查询求值时间之前 5 分钟内的最新样本。如果样本是正常样本，那么它将在瞬时向量中返回；但如果是过期的标记，那么该时间序列将不出现在瞬时向量中。需要注意的是，如果你使用了 Prometheus Export 来暴露时间戳，那么过期的标记和 Prometheus 2.x 对过期标记的处理逻辑就会失效，受影响的时间序列会继续和 5 分钟以前的旧逻辑一起执行。</p>
<h3 id="2-3-区间向量选择器"><a href="#2-3-区间向量选择器" class="headerlink" title="2.3 区间向量选择器"></a>2.3 区间向量选择器</h3><p>　　区间向量选择器返回一组时间序列，每个时间序列包含一段时间范围内的样本数据。和瞬时向量选择器不同的是，它从当前时间向前选择了一定时间范围的样本。区间向量选择器主要在选择器末尾的方括号 [] 中，通过时间范围选择器进行定义，以指定每个返回的区间向量样本值中提取多长的时间范围。例如，下面的例子可以表示最近5分钟内的所有HTTP请求的样本数据，其中[5m]将瞬时向量选择器转变为区间向量选择器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>

<p>　　时间范围通过整数来表示，可以使用以下单位之一：秒(s)、分钟(m)、小时(h)、天(d)、周(w)、年(y)。需要强调的是，必须用整数来表示时间，比如 38m 是正确的，但是 2h 15m 和 1.5h 都是错误的。注意，这里的年是忽略闰年的，永远是50*60*25*365 秒。</p>
<p>　　关于区间向量选择还需要补充的就是，它返回的是一定范围内所有的样本数据，虽然刮擦时间是相同的，但是多个时间序列的时间戳往往并不会对齐，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code=&quot;200&quot;,job=&quot;HelloWorld&quot;,method=&quot;get&quot;&#125;=[</span><br><span class="line">1@1518096812.678</span><br><span class="line">1@1518096817.678</span><br><span class="line">1@1518096822.678</span><br><span class="line">1@1518096827.678</span><br><span class="line">1@1518096832.678</span><br><span class="line">1@1518096837.678</span><br><span class="line">]</span><br><span class="line">http_requests_total&#123;code=&quot;200&quot;,job=&quot;HelloWorld&quot;,method=&quot;get&quot;&#125;=[</span><br><span class="line">4@1518096813.233</span><br><span class="line">4@1518096818.233</span><br><span class="line">4@1518096823.233</span><br><span class="line">4@1518096828.233</span><br><span class="line">4@1518096833.233</span><br><span class="line">4@1518096838.233</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>　　这是因为距离向量会保留样本的原始时间戳，不同 target 的刮擦被分布以均匀的负载，所以虽然我们可以控制刮擦和规则评估的频率，比如 5秒&#x2F;次（第一组 12、17、22、27、32、37；第二组 13、18、23、28、33、28），但是我们无法控制他们完全对齐时间戳(<a href="mailto:&#49;&#x40;&#x31;&#53;&#49;&#56;&#48;&#57;&#x36;&#x38;&#49;&#x32;&#x2e;&#54;&#55;&#x38;">&#49;&#x40;&#x31;&#53;&#49;&#56;&#48;&#57;&#x36;&#x38;&#49;&#x32;&#x2e;&#54;&#55;&#x38;</a>和<a href="mailto:&#x34;&#64;&#49;&#x35;&#49;&#x38;&#x30;&#57;&#54;&#x38;&#49;&#x33;&#x2e;&#50;&#x33;&#51;">&#x34;&#64;&#49;&#x35;&#49;&#x38;&#x30;&#57;&#54;&#x38;&#49;&#x33;&#x2e;&#50;&#x33;&#51;</a>)，因为假如有成百上千的 target，每次5秒的刮擦都会导致这些 target 在不同的位置被处理，所以时间序列一定会存在略微不同的时间点的。但是这在实际生产中并不是非常重要(偶发的不对系统造成影响的瞬时毛刺数据不是很重要)，因为 Prometheus 等指标监控本身的定位就不像 Log 监控那样精准，而是趋势准确。</p>
<p>　　最后，我们结合本节介绍的知识，来看几个关于 CPU 和 PromQL 实战案例，夯实下理论。</p>
<p>　　案例一：计算 2 分钟内系统进程的 CPU 使用率。</p>
<p>　　rate是PromQL内置函数，获取一段时间窗口的平均量。取一段时间增量的平均每秒数量，2m内总增量&#x2F;2m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(node_cpu_seconds_total&#123;&#125;[2m])</span><br></pre></td></tr></table></figure>

<p><img src="/images/1717738836-5a44808d1471fd0c680dd843e6653c35.png"></p>
<p>　　案例二：计算系统 CPU 的总体使用率，通过排除系统闲置的 CPU 使用率即可获得（without用于从计算结果中移除列举的标签，而保留其它标签）。</p>
<p>　　without 用于从计算结果中移除列举的标签，而保留其它标签。by则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过without和by可以按照样本的问题对数据进行聚合。</p>
<p>　　avg without 不按cpu标签分组，然后计算平均值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - avg without(cpu) (rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[2m]))</span><br></pre></td></tr></table></figure>

<p><img src="/images/1717738836-515d2632837bc5c09c049545d174438d.png"></p>
<p>　　案例三：node_cpu_seconds_total 可以获取当前 CPU 的所有信息。使用 avg 聚合查询到数据后，再使用 by 来区分实例，这样就能做到分实例查询各自的数据。</p>
<p>　　irate(5m)：指定时间范围内的最近两个数据点来算速率，适合快速变化的计数器（counter）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg(irate(node_cpu_seconds_total&#123;job=&quot;node-exporter&quot;&#125;[5m])) by (instance)</span><br></pre></td></tr></table></figure>

<p><img src="/images/1717738836-4983b006c7f2e3699297ace07e68c40b.png"></p>
<hr>
<p><strong>知识延伸：</strong></p>
<p>1）区间向量选择器往往和速率函数 rate 一起使用。比如子查询，以 1次&#x2F;分钟的速率采集关于 http_requests_total 指标在过去30分钟的数据，然后返回这30分钟内距离当前最近的5分钟内的采集结果，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total&#123;&#125;[5m])[30m:1m]</span><br></pre></td></tr></table></figure>

<p>2)一个区间向量表达式不能直接展示在 Graph 中，但是可以展示在 Console 视图中。</p>
<h3 id="2-4-偏移量修改器"><a href="#2-4-偏移量修改器" class="headerlink" title="2.4 偏移量修改器"></a>2.4 偏移量修改器</h3><p>　　偏移量修改器可以让瞬时向量选择器和区间向量选择器发生偏移，它允许获取查询计算时间并在每个选择器的基础上将其向前推移。</p>
<p>　　瞬时向量选择器和区间向量选择器都可以获取当前时间基准下的样本数据，如果我们要获取查询计算时间前5分钟的 HTTP 请求情况，可以使用下面这样的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;&#125; offset 5m</span><br></pre></td></tr></table></figure>

<p>　　偏移向量修改器的关键字必须紧跟在选择器{}后面，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total&#123;method=&quot;GET&quot;&#125; offset 5m)   #正确</span><br><span class="line">sum(http_requests_total&#123;method=&quot;GET&quot;&#125;) offset 5m   #错误</span><br></pre></td></tr></table></figure>

<p>　　区间向量修改器的关键字也必须跟在选择器{}后面，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total[5m] offset 5m)   #正确</span><br><span class="line">sum(http_requests_total[5m]) offset 5m   #错误</span><br></pre></td></tr></table></figure>

<p>　　偏移量修改器一般用于单条数据调试比较有帮助。而趋势变化数据中，用它较少。</p>
<h2 id="三、Prometheus的4大指标类型"><a href="#三、Prometheus的4大指标类型" class="headerlink" title="三、Prometheus的4大指标类型"></a>三、Prometheus的4大指标类型</h2><p>　　Prometheus有4大指标类型（Metrics Type），分别是 Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）和 Summary（摘要）。这是在 Prometheus 客户端（目前主要有 Go、Java、Python、Ruby 等语言版本）中提供的4种核心指标类型，但是 Prometheus 的服务端并不区分指标类型，而是简单地把这些指标统一视为无类型的时间序列。</p>
<h3 id="3-1-计数器"><a href="#3-1-计数器" class="headerlink" title="3.1 计数器"></a>3.1 计数器</h3><p>　　计数器类型代表一种样本数据单调递增的指标，在没有发生重置（如服务重启、应用重启）的情况下只增不减，其样本值应该是不断增大的。例如，可以使用 Counter 类型的指标来表示服务的请求数、已完成的任务数、错误发生的次数等。计数器指标主要有两个应用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) Inc()      //将 Counter 值加 1</span><br><span class="line">2) Add(float64) //将指定值加到 Counter 值上，如果指定值小于0，会产生 Go语言的Panic异常，进而可能导致崩溃</span><br></pre></td></tr></table></figure>

<p>　　但是，计数器计算的总数对用户来说大多没有什么用。大家千万不要用于计数器类型用于计算当前运行的进程数量、当前登录的用户数量等。</p>
<p>　　为了能够更直观地表示样本数据的变化情况，往往需要计算样本的增长速率，这时候通常使用 PromQL 的rate、topk、increase 和 irate 等函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m]) //通过 rate() 函数获取 HTTP 请求量的增长速率</span><br><span class="line">topk(10,http_requests_total)  //通过当前系统中访问量排在前10的 HTTP 地址</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>知识延伸：</strong></p>
<p>　　Prometheus 要先执行 rate() 再执行 sum()，不能执行完 sum() 再执行 rate()。</p>
<p>　　这背后与 rate() 的实现方式有关，rate()在设计上假定对应的指标应该是一个计数器，也就是只有incr（增加）和 reset（归零）两种方式。而执行了sum（）或其他聚合操作之后，得到的就不再是一个计数器了。</p>
<hr>
<p>　　<strong>increase（v range-vector）函数</strong>传递的参数是一个区间向量，increase 函数获取区间向量中的第一个和最后一个样本并返回其增长量。下面的例子可以查询 Counter 类型指标的增长速率，可以获取 http_requests_total 在最近 5 分钟内的平均样本，其中 300 代表 300 秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increase(http_requests_total[5m]) / 300</span><br></pre></td></tr></table></figure>

<hr>
<p> <strong>知识延伸：</strong></p>
<p>　　rate 和 increase 函数计算的增长量容易陷入长尾效应中。比如在某一个由于访问量或者其他问题导致 CPU 占用 100% 的情况中，通过计算在时间窗口内的平均增长率是无法反应出该问题的。</p>
<p>　　为什么监控和性能测试中，我们更关注 p95&#x2F;p99位？就是因为长尾效应。由于个别请求的响应时间需要1秒或者更久，传统的响应时间的平均值就体现不出响应时间中的尖刺，去尖刺也是数据采集中一个很重要的工序，这就是所谓的长尾效应。p95&#x2F;p99就是长尾效应的分割线，如表示99%的请求在 xxx 范围内，或者是1%的请求在 xxx 范围之外。99%是一个范围，意思是99%的请求在某一延迟内，剩下的1%就在延迟之外了。</p>
<hr>
<p>　　irate(v range-vector) 是 PromQL 针对长尾效应专门提供的灵敏度更高的函数。irate 同样用于计算区间向量的增长速率，但是其反映出的瞬时增长速率。irate 函数是通过区间向量中的最后两个样本数据来计算区间向量的增长速率的。这种方式可以避免在时间窗口范围内的”长尾问题”，并且体现出更好的灵敏度。通过 irate 函数绘制的图标能够更好地反映样本数据的瞬时变化状态。irate 的调用命令如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate(http_requests_total[5m])</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>知识延伸：</strong></p>
<p>　　irate 函数相比于 rate 函数提供了更高的灵敏度，不过分析长期趋势时或者在告警规则中，irate 的这种灵敏度反而容易造成干扰。因此，在长期趋势分析或者告警钟更推荐 rate 函数。</p>
<hr>
<h3 id="3-2-仪表盘"><a href="#3-2-仪表盘" class="headerlink" title="3.2 仪表盘"></a>3.2 仪表盘</h3><p>　　仪表盘类型代表一种样本数据可以任意变化的指标，即可增可减。它可以理解为状态的快照，Gauge 通常用于表示温度或者内存使用率这种指标数据，也可以表示随时增加或减少的 “总数”，例如当前并发请求的数量 node_memory_MemFee(主机但钱空闲的内容大小)、node_memory_MemAvailable(可用内存大小)等。在使用 Gauge 时，用户往往希望使用它们求和、取平均值、最小值、最大值等。</p>
<p>　　以 Prometheus 经典的 Node Exporter 的指标 node_filesystem_size_bytes 为例，它可以报告从 node_filesystem_size_bytes 采集来的文件系统大小，包含 device、fstype 和 mountpoint 等标签。如果想要对每一台机器上的总文件系统大小求和(sum)，可以使用如下 PromQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum without(device,fstype,mountpoint)(node_filesystem_size_bytes)</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/images/1717738836-0793b935ac2026ee2549fb0d8696e9df.png"></h3><p>　　除了求和、求最大值等，利用 Gauge 的函数求最小值和平均值原理也是类似的。除了基本的操作外，Gauge 经常结合 PromQL 的 predict_linear 和 data 函数使用。</p>
<h3 id="3-3-直方图"><a href="#3-3-直方图" class="headerlink" title="3.3 直方图"></a>3.3 直方图</h3><p>　　在大多数情况下，人们都倾向于使用某些量化指标的平均值，例如 CPU 的平均使用率、页面的平均响应时间。用这种方式呈现结果很明显，以系统 API 调用的平均响应时间为例，如果大多数 API 请求维持在 100ms 的响应方位内，而个别请求的响应时间需要 5s，就表示出现了长尾问题。</p>
<p>　　响应慢可能是平均值大导致的，也可能是长尾效应导致的额，区分两者的最简单的方式就是按照请求延迟的范围进行分区。例如，统计延迟在0<del>10ms之间的请求数有多少，在10</del>20ms之间的请求数有多少。通过 Histogram 展示监控指标，我们可以快速了解监控样本的分布情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.153.40:30207/metrics 自带的一些 Histogram 信息</span><br></pre></td></tr></table></figure>

<p>　　如上述按理所示，Histogram 类型的样本会提供 3 种指标，假设指标名称为<basename>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># HELP prometheus_http_request_duration_seconds Histogram of latencies for HTTP requests.</span><br><span class="line"># TYPE prometheus_http_request_duration_seconds histogram</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;0.1&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;0.2&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;0.4&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;1&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;3&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;8&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;20&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;60&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;120&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_bucket&#123;handler=&quot;/&quot;,le=&quot;+Inf&quot;&#125; 1</span><br><span class="line">prometheus_http_request_duration_seconds_sum&#123;handler=&quot;/&quot;&#125; 2.3757e-05</span><br><span class="line">prometheus_http_request_duration_seconds_count&#123;handler=&quot;/&quot;&#125; 1</span><br></pre></td></tr></table></figure>

<p>　　样本的值分布在 Bucket 中的数量，命名为<basename>_backet{le&#x3D;”&lt;上边界&gt;”}。这个值表示指标最小等于上边界的所有样本数量。上述案例中的prometheus_http_request_duration_seconds_bucket{handler&#x3D;”&#x2F;“,le&#x3D;”0.1”} 1, 1就代表在总共的1次请求中，HTTP 请求响应时间 &lt;&#x3D; 0.1s的请求一共1次。</p>
<p>　　所有样本值的总和，命名为&lt; basename&gt;_sum。上述案例中的 prometheus_http_request_duration_seconds_sum{handler&#x3D;”&#x2F;“} 2.3757e-05 表示发生的1次 HTTP请求总响应时间是 2.3757e-05s。</p>
<p>　　样本总数，命名为<basename>_count，其值和<basename>_bucket{le&#x3D;”+Inf”} 相同。</p>
<p>　　sum 函数和 count 函数相除，可以得到一些平均值，比如 Prometheus 一天内的平均压缩时间，可由查询结果除以 instance 标签数量得到，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum without(instance) (rate(prometheus_tsdb_compaction_duration_sum[1d])) / sum without(instance) (rate(prometheus_tsdb_compction_duration_count[1d]))</span><br></pre></td></tr></table></figure>

<p>　　除了 Prometheus 内置的压缩时间，prometheus_local_storage_series_chunks_persisted 表示 Prometheus 中每个时序需要存储的 chunk 数量，也可以用于计算待持久化的数据的分位数。</p>
<h3 id="3-4-摘要"><a href="#3-4-摘要" class="headerlink" title="3.4 摘要"></a>3.4 摘要</h3><p>　　与 Histogram 类型类似，摘要用于表示一段时间内的数据采样的结果(通常是请求持续时间或响应大小等)，但它直接存储了分位数(通过客户端计算，然后展示出来)，而非通过区间计算。因此，对于分位数计算，Summary在通过PromQL进行查询时会有更好的性能表现，而 Histogram 则会消耗更多的资源。反之，对于客户端而言，Histogram 消耗的资源更少。在选择这两种方式时，用户应该根据座机的实际场景选择。</p>
<hr>
<p><strong>知识延伸： Summary 和 Histogram 的异同</strong></p>
<ol>
<li><p>它们都包含了<basename>_sum 和&lt;base_name&gt;_count 指标。</p>
</li>
<li><p>Histogram 需要通过<basename>_bucket来计算分位数，而 Summary 则直接存储了分位数的值。</p>
</li>
<li><p>如果需要汇总或者了解要观察的值的范围和分布，建议使用 Histogram;如果并不在乎要观察的值的范围和分布，仅需要精确的 quantile 值，那么建议使用 Summary。</p>
</li>
</ol>
<hr>
<h2 id="四、13种聚合操作"><a href="#四、13种聚合操作" class="headerlink" title="四、13种聚合操作"></a>四、13种聚合操作</h2><p>　　在实际生产环节中，往往有着成百上千的实例，用户不可能逐个筛选每个实例的指标。聚合操作(Aggregation Operator)允许用户在一个应用程序中或多个应用程序之间对指标进行聚合计算，可以对瞬时表达式返回的样本数据进行聚合，形成一个具有较少样本的新的时间序列。聚合操作只对瞬时向量起作用，输出的也是瞬时向量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询系统所有 HTTP 请求的总量</span><br><span class="line">sum(http_request_total)</span><br><span class="line"></span><br><span class="line">#按照mode计算主机 CPU 的平均使用时间</span><br><span class="line">avg(node_cpu) by (mode)</span><br><span class="line"></span><br><span class="line">#查询各个主机的 CPU 使用率</span><br><span class="line">sum(sum(irate(node_cpu&#123;mode!=&#x27;idle&#x27;&#125;[5m])) / sum(irate(node_cpu[5m]))) by (instance)</span><br></pre></td></tr></table></figure>

<ul>
<li>sum（求和）</li>
<li>min（最小值）</li>
<li>max（最大值）</li>
<li>avg（平均值）</li>
<li>stddev（标准差）</li>
<li>stdvar（标准差异）</li>
<li>count（计数）</li>
<li>count_values(对 value 进行计数)</li>
<li>bottomk（样本值最小的 k 个元素）</li>
<li>topk（样本值最大的 k 个元素）</li>
<li>quantile（分布统计）</li>
</ul>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/06/07/Prometheus-Query-Language/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Prometheus/" rel="tag">Prometheus</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/06/07/Exporter%EF%BC%88Nginx%E7%9B%91%E6%8E%A7%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Exporter（Nginx监控）
          
        </div>
      </a>
    
    
      <a href="/2024/06/07/SprintBoot-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">SprintBoot 可视化监控</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> JinTao Li
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="https://beian.miit.gov.cn/" target="_black" rel="nofollow">鲁ICP备88888888</a>
        </li>
        
    </ul>
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">青岛公安网备01234567890123号</a>
      </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Lijintao&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/u013235026">CSDN</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.cnblogs.com/jintaoli">博客园</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/images/272a163694dd8a415a43dbf85ac34778.jpg">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=2049529248&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "jintao1210";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "请输入访问密码",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "确定",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "密码错误，请重试",
            confirmButtonText: "确定",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>